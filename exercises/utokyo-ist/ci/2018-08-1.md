# 2019年度 創造情報学 第1問

この解答ではPythonの文法に沿って打ち込んでいますが、問題文の指示は擬似コードなので、本番では適切に抽象化して良いと思います。

## (1)

```python
visited = []
for i in range(n):
    for j in range(n):
        visited[i][j] = False

count = 0

def visit(x: int, y: int):
    visited[i][j] = True
    count += 1
    for i in [x-1, x, x+1]:
        for j in [y-1, y, y+1]:
            if 0 <= i and i < n and 0 <= j and j < n and \
                P[i][j].brightness > threshold and visited[i][j] is False:
                visit(i, j)

visit(x, y)
```

計算量は$O(n^2)$

## (2)

明るさの合計を用いた最良優先探索（ダイクストラ法）で解く。

```python
from collections import defaultdict
import heapq

def dijkstra(y_s: int, x_s: int, y_g: int, x_g: int, P: list):
    accum_brs_dict = defaultdict(lambda: infinity)
    accum_brs_dict[(y_s, x_s)] = P[y_s][x_s].brightness # 累積の明るさを持つ辞書
    pq = [(P[y_s][x_s].brightness, (y_s, x_s), [(y_s, x_s)])]

    while pq:
        accum_brightness, (y, x), path = heapq.heappop(pq)
        if accum_brightness > accum_brs_dict[(y, x)]:
            continue
        if (y, x) == (y_g, x_g):
            return accum_brightness, path
        for dy, dx in [(-1,-1), (-1,0), (-1,1), (0,-1), (0,1), (1,-1), (1,0), (1,1)]:
            y_n, x_n = y + dy, x + dx
            if 0 <= y_n < len(P) and 0 <= x_n < len(P[0]):
                new_brightness = accum_brightness + P[y_n][x_n].brightness
                if new_brightness < accum_brs_dict[(y_n, x_n)]:
                    accum_brs_dict[(y_n, x_n)] = new_brightness
                    new_path = path + [(y_n , x_n)]
                    heapq.heappush(pq, (new_brightness, (y_n, x_n), new_path))

    return infinity, []
```

計算量は$O(n^2 \log n^2)$

## (3)

上端の全ての点について、下端の全ての点までの最も暗い距離を計算し、最も暗い2点間の距離を採用する。動的計画法で解く。

(コードが行数制限を満たせず)

```python
dp = []
for i in range(0, n/2):
    for j in n:
        for k in range(n/2, n):
            for l in n:
                dp[(i,j)][(k,l)] = None

def calc_darkest(start: tuple[int, int], end: tuple[int, int]):
    if dp[start][end] is not None:
        return dp[start][end]
    if end[0] - start[0] > 1:
        darkest = infinity
        for j in [start[1]-1, start[1], start[1]+1]:
            for l in [end[1]-1, end[1], end[1]+1]:
                if 0 < j and j < n and 0 < l and l < n:
                    brightness = calc_darkest((start[0]+1, j), (end[0]-1, l)) + P[start[0]][start[1]].brightness + P[end[0]][end[1]].brightness
                    darkest = min(darkest, brightness)
        dp[(start[0], start[1])][(end[0], end[1])] = darkest
        return darkest
    else:
        return P[start[0]][start[1]].brightness + P[end[0]][end[1]].brightness

for j in n:
    for l in n:
        calc_darkest((0, j), (n-1, l))
```

計算量は$O(n^3)$

## (4)

各ピクセルが隣り合っているピクセルのみ1になるような、0と1からなる行列を用意し、その積として表す。

(未回答)

## (5)

(未回答)
