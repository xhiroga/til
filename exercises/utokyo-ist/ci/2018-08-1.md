# 2019年度 創造情報学 第1問

この解答ではPythonの文法に沿って打ち込んでいますが、問題文の指示は擬似コードなので、本番では適切に抽象化して良いと思います。

## (1)

```python
visited = []
for i in range(n):
    for j in range(n):
        visited[i][j] = False

count = 0

def visit(x: int, y: int):
    visited[i][j] = True
    count += 1
    for i in [x-1, x, x+1]:
        for j in [y-1, y, y+1]:
            if 0 <= i and i < n and 0 <= j and j < n and \
                P[i][j].brightness > threshold and visited[i][j] is False:
                visit(i, j)

visit(x, y)
```

計算量は$O(n^2)$

## (2)

明るさの合計を用いた最良優先探索（ダイクストラ法）で解く。

```python
from collections import defaultdict
import heapq

def dijkstra(y_s: int, x_s: int, y_g: int, x_g: int, P: list):
    accum_brs_dict = defaultdict(lambda: infinity)
    accum_brs_dict[(y_s, x_s)] = P[y_s][x_s].brightness # 累積の明るさを持つ辞書
    pq = [(P[y_s][x_s].brightness, (y_s, x_s), [(y_s, x_s)])]

    while pq:
        accum_brightness, (y, x), path = heapq.heappop(pq)
        if accum_brightness > accum_brs_dict[(y, x)]:
            continue
        if (y, x) == (y_g, x_g):
            return accum_brightness, path
        for dy, dx in [(-1,-1), (-1,0), (-1,1), (0,-1), (0,1), (1,-1), (1,0), (1,1)]:
            y_n, x_n = y + dy, x + dx
            if 0 <= y_n < len(P) and 0 <= x_n < len(P[0]):
                new_brightness = accum_brightness + P[y_n][x_n].brightness
                if new_brightness < accum_brs_dict[(y_n, x_n)]:
                    accum_brs_dict[(y_n, x_n)] = new_brightness
                    new_path = path + [(y_n , x_n)]
                    heapq.heappush(pq, (new_brightness, (y_n, x_n), new_path))

    return infinity, []
```

計算量は$O(n^2 \log n^2)$

## (3)

上から1行ごとに、全てのピクセルについて、最暗経路を求める。

```python
dp = []
for y in range(len(P)):
    for x in range(len(P[0])):
        dp[y][x] = (infinity, []) # 明るさの合計, 経路

for x in range(len(P[0])):
    dp[0][x] = (P[0][x].brightness, [(0, x)])   # 1行目の累積明るさはそのピクセル自身の明るさ

for y in range(1, len(P)):
    for x in range(0, len(P[y])):
        for dx in [-1, 0, 1]:
            if 0 <= (x_u := x + dx) < len(P[y-1]):
                brightness = P[y][x].brightness
                if (accum_brightness := dp[y-1][x_u][0] + brightness) < dp[y][x][0]
                    dp[y][x] = (accum_brightness, dp[y-1][x_u][1] + [(y, x)])

brightness, path = min(dp[-1], key=lambda x: x[0])
```

計算量は$O(n^2)$

ちなみに、すべての行をメモ化するのではなく、直近の2行だけをメモ化することで、メモリを節約できる。

## (4)

各ピクセルが隣り合っているピクセルのみ1になるような、0と1からなる行列を用意し、その積として表す。

(未回答)

## (5)

(未回答)
