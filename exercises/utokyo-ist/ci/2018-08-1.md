# 2019年度 創造情報学 第1問

## (1)

```python
visited = []
for i in n:
    for j in n:
        visited[i][j] = False

count = 0
for i in [x-1, x, x+1]:
    for j in [y-1, y, y+1]:
        if P[i][j].brightness > threshold and visited[i][j] is not False:
            count += 1
            visited[i][j] = True
```

計算量は$O(n^2)$

## (2)

明るさの合計を基準とした最良優先探索で解く。

(未回答)

## (3)

上端の全ての点について、下端の全ての点までの最も暗い距離を計算し、最も暗い2点間の距離を採用する。動的計画法で解く。

(コードが行数制限を満たせず)

```python
dp = []
for i in range(0, n/2):
    for j in n:
        for k in range(n/2, n):
            for l in n:
                dp[(i,j)][(k,l)] = None

def calc_darkest(start: tuple[int, int], end: tuple[int, int]):
    if dp[start][end] is not None:
        return dp[start][end]
    if end[0] - start[0] > 1:
        darkest = infinity
        for j in [start[1]-1, start[1], start[1]+1]:
            for l in [end[1]-1, end[1], end[1]+1]:
                if 0 < j and j < n and 0 < l and l < n:
                    brightness = calc_darkest((start[0]+1, j), (end[0]-1, l)) + P[start[0]][start[1]].brightness + P[end[0]][end[1]].brightness
                    darkest = min(darkest, brightness)
        dp[(start[0], start[1])][(end[0], end[1])] = darkest
        return darkest
    else:
        return P[start[0]][start[1]].brightness + P[end[0]][end[1]].brightness

for j in n:
    for l in n:
        calc_darkest((0, j), (n-1, l))
```

計算量は$O(n^3)$

## (4)

各ピクセルが隣り合っているピクセルのみ1になるような、0と1からなる行列を用意し、その積として表す。

(未回答)

## (5)

(未回答)
