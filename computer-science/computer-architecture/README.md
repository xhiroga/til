# コンピュータアーキテクチャ・OS・電子回路・論理回路

## 電子回路

TTLやCMOSなどの論理回路について語る上で、トランジスタを含む電子回路図を用いる。論理回路の教科書と演習のための最低限の知識を次にまとめた。

<!-- TODO -->

## 数体系・符号体系

### n進数の小数部

![n進数の小数部](/images/n進数の小数部.svg)

### 基数変換 (radix conversion)

n進数→10進数は次のように考える。4,000（よんせん）は40 00（よんじゅう ひゃく）と考えることができる。同様に、0.05 = 5厘（ごりん）は0.5分（れいてんごぶ）とも考えられる。このように、指数の絶対値が大きい桁の数字による数は、指数の絶対値が小さい桁の数字でも表せる。n進数→10進数の変換では、$n^{|m|}$の倍数を$n^{|m-1|}$の倍数で表す操作を繰り返す。

また、10進数→n進数は次のように考える。指数の絶対値が小さい桁の数は、指数の絶対値が大きい桁の数としては表すことができない。（ここで4は0.4 10と言い出すとややこしいので一旦考えない）そのため、nで割って/掛けて、余り/整数部を指数の絶対値が小さい桁の数にする。

<!-- ちょっと説明がこなれていないが、時間の関係でここまでとする。 -->

最後に、n進数・10進数間の変換について表と図にまとめた。

| 変換\部分    | 整数部                                                       | 小数部                                                       |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| n進数→10進数 | 大きい桁から順に、nを掛けて1つ小さい桁の値と足す、を繰り返す | 小さい桁から順に、nで割って1つ大きい桁の値と足す、を繰り返す |
| 10進数→n進数 | nで割って余りを取り出し、下位桁に並べるのを繰り返す          | nを掛けて整数部を取り出し、上位桁に並べるのを繰り返す        |

![n進数](/images/n進数.svg)

### 補数 (complement)

足すと基数になるものが補数である。例えば、876の10の補数(1000の補数とは言わない)は124である。

要するに1000からその数を引けば求められるのだが、代わりに999から引いて1を足して求めると繰り下がりがなくて計算しやすい。各桁の9の補数を求めて、その値を連結して1を足すとも言える。

同様に、16の補数、2の補数などn進数の補数が存在する。2の補数を求めるためには、各桁の1の補数を求めて、その結果を連結して1を足すことになる。つまり全桁を反転させてから1を足すのに等しい。この全桁を反転させた値も1の補数と呼ぶが、それ以外の補数の定義とは違って紛らわしいのでやめたほうがいいと思う。

## 論理演算

<!-- ドントケア項は二重に括ったほうがお得 -->

<!-- アクティブ状態とインアクティブ状態と、LowとHighの区別がつかない -->

### MIL記法

米軍の物資調達のために開発された米軍ミル企画の一つである、[MIL-STD-806](https://bitsavers.org/pdf/mil-std/MIL-STD-806B_Graphical_Symbols_For_Logic_Diagrams_19620226.pdf)に基づいた論理回路の記法。

<!-- 状態◯がNotを指すのがよく分からない -->

## 組み合わせ回路 (combinational logical circuit)

<!-- 書き方について -->

### 加減算器

#### キャリールックアヘッド

2進数におけるn桁目の繰り上がりの判断は、n桁目がともに1（$A_n \cdot B_n$）であるか、またはN桁目のいずれかが1かつn-1桁目が繰り上がり（$(A_n \oplus B_n) \cdot C_{n-1}$）で行われる。2024年現在に一般的な64ビットのCPUは、64桁の2進数の加算も行うから、前の桁の結果を待っていると処理が非常に遅くなる。そこで前桁の出力を待つことなく、n桁目の繰り上がり判断でn-1桁目, n-2桁目...1桁目を並列に演算するのがキャリールックアヘッド処理である。

個人的な意見だが、キャリールックアヘッド処理の本質を捉えるには、「前桁の出力を用いず、入力を直接用いる」という説明は不正確である。更に、「繰り上がりがあり得る全てのパターンを並列に処理し、最後にORを取る」という説明も不十分と考える。例えば、$A=00001$と$B=01111$の足し算では、$A \cdot B = 1$かつ$A_n \oplus B_n = 1 | n = 2,3,4,5$のパターンで繰り上がりが起きるが、まず1桁目を加算、次に2桁目と2桁目のXORのAND...と順番に処理していたら、前桁の出力を用いるのと計算量が変わらない。そうではなく、n入力のANDゲートを用いることで、$((A_1 \cdot B_1) \cdot (A_2 \oplus B_2)) \cdot((A_3 \oplus B_3)\cdot(A_4 \oplus B_4))$のように各桁のANDを取るのが並列化され、最も時間のかかるパターンの計算量を$log_2N$に抑えられるのである。

### エンコーダ・デコーダ

### マルチプレクサ・デマルチプレクサ

### フリップフロップ

デジタル回路で入力を保持したい場合、回路にループを作ればよい。

入力を後から取り出せる回路を広義のフリップフロップという。値を入力すると状態が変わるように見えるため、フリップフロップという名前といわれている。[^renesas_flipflop]
[^renesas_flipflop]: [順序回路、フリップフロップ](https://www.renesas.com/jp/ja/support/engineer-school/digital-circuits-03-sequential-logic)

しかし、単に回路をループさせると、一度の（厳密には、同一のクロックパルス内で）入力で出力が何度も変わってしまう。そこでクロック毎に一度だけ値が変わるようにしたのが、狭義のフリップフロップである。そうでないものは非同期式フリップフロップ、またはラッチと呼ぶ。

フリップフロップの種類について、次の通りまとめる。

- 入力による分類
  - SR:
  - D:
  - JK: JKフリップフロップ。ICの開発者であるJack Kilby（ジャック・キルビー）に由来するとする説もあるが、証拠はない。[^why-called-jk-flip-flop] SRフリップフロップの改良版で、入力が(1,1)のときに出力が反転する。
  - T: Toggle（トグル）フリップフロップ。

[^why-called-jk-flip-flop]: [Why called JK flip-flop?](https://www.edaboard.com/threads/why-called-jk-flip-flop.25589/)

> [!NOTE]
なぜSRラッチにSet/Resetが必要なのかを自分なりに考えたが、入力が1つでは保持した値の取り出し・0のセット・1のセット、という3種類のコマンドを表現できないためという結論になった。High/Lowに加えてNullがある世界なら入力が1つのSRラッチが存在するかもしれない。  
また、現実世界でフリップフロップに相当するものがないかを考えた。電流のように流れ続けるが、初期の入力を保ち続けるものがないだろうか。水泳のインターバルトレーニング（サイクル）が相当するなと思った。25mを40秒サイクルで回るとき、1~40, 81~120, ...秒目にいる方が、スタートしたプールサイドである。

- 同期の仕組みによる分類
  - ラッチ（非同期式）
  - フリップフロップ（同期式）
  - マスタスレーブ型: FFを2つ連結させ、クロックが1のとき1つ目に、0のとき2つ目に書き込む
  - エッジトリガ型: マスタスレーブ型ではクロックの立ち上がりから立ち下がりまで入力を継続する必要がある点を改良した。SRラッチを組体操のように3つ重ねた構成。立ち上がり時に書き込んで以降はロックアウトされる仕組み。

<!-- TODO: エッジトリガ型よく分かっていない -->

フリップフロップの分類を、次の通り表にした。

| 入力 | ラッチ | フリップフロップ | マスタスレーブ | エッジトリガ |
| ---- | ------ | ---------------- | -------------- | ------------ |
| SR   | ◯      | ◯                | ◯              | ◯            |
| D    | ◯      | ◯                | ◯              | ◯            |
| JK   | -      | -                | ◯              | ◯            |
| T    | -      | -                | ◯              | ◯            |

## 順序回路

<!-- 特性方程式と論理式、特性表と真理値表の関係 -->

### レジスタ

> [!NOTE]
プログラミング中に明示的にレジスタを読み書きしたことないですけど？というのが気になった。  
例えばHackプラットフォーム[^nisan_2005]では、CPUに対するメモリ入力が1つだけのため、2つのメモリの値を対象に操作する（比較・四則演算・代入など）場合、片方をCPU内のデータレジスタに保存する必要がある。  
制約がそれだけなら、メモリ入力を2つにすることで解決できそうだ。しかし、高級言語での1命令が機械語で複数命令になり、かつ1つの値を連続して使う場合はどうだろうか。  
例えば数の3乗はどうか。おそらく機械語では、乗算を2回行うと思われる。その場合、毎回メモリの値を要求していては時間がかかる。そのような場合に備え、内部的にレジスタに値を保持するようにコンパイルしていると考えれば良さそうだ。

[^nisan_2005]: [コンピュータシステムの理論と実装](https://amzn.to/4dJ5RDS)

## 論理回路

- TTL
- CMOS
- プログラマブル・デバイス
  - PLA
  - PAL
  - GAL
  - FPGA
  - CPLD

## コンピュータアーキテクチャ

### メモリ (memory)

記憶装置。ランダムアクセス構造のメモリでは、固定幅のセルが連続して並んでおり、この固定幅のセルを「ワード」「ロケーション」と呼ぶ。  

メモリの構成要素は次の通り。

- data memory （データメモリ）
- instruction memory （命令メモリ）

メモリの種類は次の通り。主記憶装置・補助記憶装置のいずれの役割も考えられる。

- ROM: Read Only Memoryの略。と言っても全く書き込めない訳ではなく（そうだとしたら読み込む対象が存在しない）、プロセッサの書き込み命令では書き込めない、ということ
  - マスクROM: 初期のROMで、ファミコンに搭載されているROMもマスクROMである。
  - PROM
    - ヒューズROM
    - EPROM
      - UVEPROM
      - EEPROM
      - フラッシュメモリ
- RAM: Random Access Memoryの略。端からデータを読み取るSequential Access Memory (SAM)の対義語だった。その意味は薄れており、Read Write Memory (RAM)の代わりに読み書き可能なメモリを指す言葉として定着している。
  - SRAM
  - DRAM

> [!NOTE]
読み書き可能であることは、メモリが主記憶装置である必要条件ではない。言い換えると、読み込み専用の主記憶装置も普通にありえる。
組み込みシステムやBIOS、UEFIファームウェアはROMが主記憶装置の役割を果たしているとみなすことができる。

### CPU

CPUは、ノイマン型コンピュータにおける演算装置と制御装置を担う。CPUの構成要素は次の通り。

- 演算装置
  - ALU
  - 汎用レジスタ
  - フラグレジスタ
- 制御装置
  - program counter register (PC)（プログラムカウンタレジスタ）: 次に読み込むべきメモリのアドレスを保持する。命令の実行中に書き換えられる。現在の命令にgotoが含まる場合はそちらに、そうでない場合はインクリメントする。
  - instruction register （命令レジスタ）
  - decoder （デコーダ）

> [!NOTE]
CPUがメモリをフェッチする、という表現が不思議だったのだが、毎クロックメモリ自体は読んでいて、次のクロックで読みたいアドレスを出力しておく、という言い方ならしっくり来るかも。

### 入出力装置

入出力装置はCPUに対して抽象化されているべきであり、その方法がメモリマップドI/Oである。すべてのデバイスは、CPUから見るとメモリ上の領域に過ぎない。

### 機械語

## References

- [論理回路入門 | 坂井修一](https://amzn.to/4aLvj99)
- [論理回路入門 | 浜辺隆二](https://amzn.to/4bL7Y8L)
