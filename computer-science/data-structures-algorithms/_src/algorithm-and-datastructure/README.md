# [プログラミングコンテスト攻略のためのアルゴリズムとデータ構造](https://amzn.to/3QAHDSk)

[![プログラミングコンテスト攻略のためのアルゴリズムとデータ構造](https://m.media-amazon.com/images/I/81KTlXyTVaL._SL1500_.jpg)](https://amzn.to/3QAHDSk)

## 2章 アルゴリズムと計算量

時間計算量と領域計算量について。領域計算量は空間計算量とも言う。

## 5章 探索

### 番兵

- `for`ループまたは`while`ループで、探索のための比較以外に終了条件の判定を行うことが面倒であるため、リストの最後に目的のデータをダミーで入れておく。
- Pythonでループを実装する場合や、TypeScriptで`find`などを用いる場合、勝手に最後まで探索してくれるので考慮不要。

### ハッシュの衝突

アルゴリズム図鑑で紹介されているチェーン法の他に、オープンアドレス法による対応がある。オープンアドレス法には、線形走査法とダブルハッシュ法がある。

- 線形走査法
  - 衝突が発生した場合、その1つ後ろの位置を格納箇所とする
  - 線形走査法・オープンアドレス法の両方に言えるが、いずれはハッシュ表が満杯になる。
- ダブルハッシュ法
  - ハッシュが衝突したら、引数に衝突回数を加えて再度ハッシュを求める。

[ハッシュ探索②（オープンアドレス法） | Programming Place Plus　アルゴリズムとデータ構造編【探索アルゴリズム】　第７章](https://programming-place.net/ppp/contents/algorithm/search/007.html#linear_probing)

## 7章 高等的整列

### パーティション

![パーティション](./images/パーティション.svg)

### クイックソート

再帰的にパーティションを行う。

### 計数ソート

[計数ソート | アルゴリズムビジュアル大事典](https://yutaka-watanobe.github.io/star-aida/1.0/algorithms/counting_sort/print.html)を参照。

## 10章 ヒープ

- 最小ヒープは、親が子よりも小さく、根が最小になるヒープ。単にヒープといえば最小ヒープ。
- 最大ヒープはその逆となる。
- 二分ヒープの読みは 「にぶん」ヒープ
- 二分ヒープと優先度付きキューの違いは、（WIP）

## 11章 動的計画法

- あずぱんさん曰く「表的計画法」。
  - [動的計画法(DP)をみんながわかるように超ていねいにじっくり説明した | あずぱん動画](動的計画法(DP)をみんながわかるように超ていねいにじっくり説明した)

### 連鎖行列積

なるべく大きい数字を早めに消してしまうのが方針となる。

## 12章 グラフ

### 隣接リスト

- メモリが少ない（＝文字数が少なく済む）性質から、競プロでは、グラフは隣接リストに近い形式で渡されることが多い。

### 隣接行列

## 13章 重み付きグラフ

### Prim's algorithm（プリム法）

- 最小全域木を求めるのに用いる。
- 二分ヒープを用いることで高速化できる。
- [プリム法 (Prim's Algorithm) | サルでもわかるアルゴリズム](https://www.youtube.com/watch?v=anuJPP3FZ8c)が分かりやすかった。

### Dijkstra's algorithm（ダイクストラ法）

- 単一始点最短経路を求めるのに用いる。計算量は$O(|V|^2)$になる。
- 自分なりに言い換えると、「近さランキング法」。
- 隣接リストと二分ヒープを用いると、計算量は$O((|V|+|E|)log|V|)$になる。
- 隣接リストと優先度付きキューを用いると、計算量は同じく$O((|V|+|E|)log|V|)$になる。
  - [Dijkstra’s Algorithm | Depth First](https://www.youtube.com/watch?v=NyrHRNiRpds)が非常に分かりやすい。
  - ウィザードリィのような主観視点で例えると次の通り。
    1. 今いる場所（＝頂点）から見える場所について、1つづつ距離を書き留め、探索候補（優先度付きキュー）に加える。
    2. 全て書き留めたら、最も近い場所を候補から選んで進む。
    3. 同じく、進んだ先から見える場所について、1つづつ距離を測る。その時、すでに書き留めた場所だったなら、今いる場所を経由した方が近道である場合に限って書き留め、探索候補に加える。
    4. 書き留めたら、またスタートに戻ってから、次に近い場所に進む。これを場所の数繰り返す（注）
  - 注: 同じ場所を2回訪問することはない。言い換えると、探索候補の中で一番近い場所だけは、後からより近いルートが見つかることは無い。


## 14章 高度なデータ構造

### Union-Find

互いに素な集合がある時に、ある2つの要素が同じ集合に属しているか？を調べることをUnion-Findという。

集合を木構造で表したとき、同じ集合に属しているか？を調べるのは根を求めることに等しく、計算量が$O(N)$となりえる。

しかし、union by rank を行うことで$O(log N) に、さらに経路圧縮を行うことで$O(α(N))$となる。$α(N)$はアッカーマンの逆関数と呼ばれ、増加がとても遅いことで知られる。[^Union-Find]

- union by rank: 2つの木を合体させるとき、背の高い木に背の低い木をつなげる
- 経路圧縮: find処理時、中間節点を全て根に繋ぎなおす

[^Union-Find]: [Union-Find の 2 つの工夫](https://algo-method.com/descriptions/133)

## 参考

- [プログラミングコンテスト攻略のためのアルゴリズムとデータ構造](https://amzn.to/3QAHDSk)
- [アルゴリズム | ともめも](https://www.tomotaku.com/category/algorithm/)
