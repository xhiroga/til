# Data structures and algorithms (データ構造・アルゴリズム)

## データ構造

### ヒープ

- 最小ヒープは、親が子よりも小さく、根が最小になるヒープ。単にヒープといえば最小ヒープ。
- 最大ヒープはその逆となる。
- 二分ヒープの読みは 「にぶん」ヒープ
- 二分ヒープと優先度付きキューの違いは、（WIP）

### Union-Find

互いに素な集合がある時に、ある2つの要素が同じ集合に属しているか？を調べることをUnion-Findという。

集合を木構造で表したとき、同じ集合に属しているか？を調べるのは根を求めることに等しく、計算量が$O(N)$となりえる。

しかし、union by rank を行うことで$O(log N) に、さらに経路圧縮を行うことで$O(α(N))$となる。$α(N)$はアッカーマンの逆関数と呼ばれ、増加がとても遅いことで知られる。[^Union-Find]

- union by rank: 2つの木を合体させるとき、背の高い木に背の低い木をつなげる
- 経路圧縮: find処理時、中間節点を全て根に繋ぎなおす

[^Union-Find]: [Union-Find の 2 つの工夫](https://algo-method.com/descriptions/133)

### 参考

- 10章 ヒープ
- 14章 高度なデータ構造

## アルゴリズム

### 番兵

- `for`ループまたは`while`ループで、探索のための比較以外に終了条件の判定を行うことが面倒であるため、リストの最後に目的のデータをダミーで入れておく。
- Pythonでループを実装する場合や、TypeScriptで`find`などを用いる場合、勝手に最後まで探索してくれるので考慮不要。

### ハッシュの衝突

アルゴリズム図鑑で紹介されているチェーン法の他に、オープンアドレス法による対応がある。オープンアドレス法には、線形走査法とダブルハッシュ法がある。

- 線形走査法
  - 衝突が発生した場合、その1つ後ろの位置を格納箇所とする
  - 線形走査法・オープンアドレス法の両方に言えるが、いずれはハッシュ表が満杯になる。
- ダブルハッシュ法
  - ハッシュが衝突したら、引数に衝突回数を加えて再度ハッシュを求める。

[ハッシュ探索②（オープンアドレス法） | Programming Place Plus　アルゴリズムとデータ構造編【探索アルゴリズム】　第７章](https://programming-place.net/ppp/contents/algorithm/search/007.html#linear_probing)

### ソート

- 挿入ソート
  - カードの山を右手に取り、1番コストの低いカード、2番目にコストの低いカード…と、順番にカードを左手に移すイメージ。
  - 個人的には左手ソートと呼びたい。
- 選択ソート
  - データの先頭（または後方）が徐々に整理済みになっていく点は、挿入ソートと変わらない。
  - 1番小さい（大きい）値、2番目に小さい（大きい）値…と順番に探していく点と、値が見つかった後は元々n番目にいた値が入れ替わりで飛ばされてしまう点が異なる。
  - この入れ替わりで飛ばされてしまう点が面白いので、個人的には（ダンジョン飯の）ミスルンソートと呼びたい。
- バブルソート
  - 右から左に、小さい値がバトンタッチしながらやってくる様子から、個人的には玉突きソートと呼びたい。
- シェルソート
- マージソート
- クイックソート
  - 再帰的にパーティションを行う。
- 計数ソート
  - [計数ソート | アルゴリズムビジュアル大事典](https://yutaka-watanobe.github.io/star-aida/1.0/algorithms/counting_sort/print.html)を参照。
- 基数ソート

シェルソート

![シェルソート（螺旋本）](/images/シェルソート（螺旋本）.svg)

パーティション

![パーティション](/images/パーティション.svg)

### ソート: 参考

- 5章 探索
- 7章 高等的整列

## アルゴリズムの解析

- 時間計算量と領域計算量について。領域計算量は空間計算量とも言う。
- 漸近的な記法は次の通り
  - 𝑜
  - 𝑂
  - Θ
  - Ω
  - 𝜔

### アルゴリズムの解析: 参考

- 2章 アルゴリズムと計算量




## 動的計画法

- あずぱんさん曰く「表的計画法」。
  - [動的計画法(DP)をみんながわかるように超ていねいにじっくり説明した | あずぱん動画](動的計画法(DP)をみんながわかるように超ていねいにじっくり説明した)

### 連鎖行列積

なるべく大きい数字を早めに消してしまうのが方針となる。

### 参考

- 11章 動的計画法

## グラフ

次のような問題がある。

- SSSP (Single Source Shortest Path, 単一始点最短経路)
- APSP (All Pair Shortest Path, 全点対最短経路)
- Articulation (関節点)の検出

### 隣接リスト

- メモリが少ない（＝文字数が少なく済む）性質から、競プロでは、グラフは隣接リストに近い形式で渡されることが多い。

### 隣接行列


### Prim's algorithm（プリム法）

- 最小全域木を求めるのに用いる。
- 二分ヒープを用いることで高速化できる。
- [プリム法 (Prim's Algorithm) | サルでもわかるアルゴリズム](https://www.youtube.com/watch?v=anuJPP3FZ8c)が分かりやすかった。

### Dijkstra's algorithm（ダイクストラ法）

- 自分なりに言い換えると、「近さランキング法」。
- 単一始点最短経路を求めるのに用いる。計算量は$O(|V|^2)$になる。
- 隣接リストと優先度付きキューを用いると、計算量は$O((|V|+|E|)log|V|)$になる。
  - [Dijkstra’s Algorithm | Depth First](https://www.youtube.com/watch?v=NyrHRNiRpds)が非常に分かりやすい。
  - ウィザードリィのような主観視点で例えると次の通り。
    1. 今いる場所（＝頂点）から見える場所について、1つづつ距離を書き留め、探索候補（優先度付きキュー）に加える。
    2. 全て書き留めたら、最も近い場所を候補から選んで進む。
    3. 同じく、進んだ先から見える場所について、1つづつ距離を測る。その時、すでに書き留めた場所だったなら、今いる場所を経由した方が近道である場合に限って書き留め、探索候補に加える。
    4. 書き留めたら、またスタートに戻ってから、次に近い場所に進む。これを場所の数繰り返す（注）
  - 注: 同じ場所を2回訪問することはない。言い換えると、探索候補の中で一番近い場所だけは、後からより近いルートが見つかることは無い。
- 螺旋本には、隣接リストと二分ヒープを用いると、計算量は$O((|V|+|E|)log|V|)$になる、とあるが...正直言って優先度付きキューでの実装より複雑だし計算量も変わらないので、私は理解していません...。

### Bellman Ford's algorithm（ベルマンフォード法）

- ダイクストラ法とは異なり、負の重みがあっても機能する。
- また、負の閉路を検出できる。
- 完全にイメージだけの説明になるが…例えば本のページを逆から読んでいたとして、1周目に意味が理解できるのは1ページ目だけになる。2周目には、前の周回で1ページ目を読んでいるから2ページ目が理解できる。そのようにして、最悪でもページ数分周回すれば本の内容が理解できる、ということになる。という感じのアルゴリズム。
- [Bellman-Ford in 5 minutes | Michael Sambol](https://www.youtube.com/watch?v=obWXjtg0L64)が分かりやすい。

### Floyd–Warshall Algorithm（ワーシャルフロイド法）

### Topological Sort（トポロジカルソート）

- 自分なりに言い換えると「左手法」。迷路の左手法と考え方が同じだから。
- 左手法の要領でグラフを探索し、そこから先は行き止まり、というところまで行ったら現在地をリストに記録する。
- 行き止まりから引き返すごとに、そこから先が行き止まりなら現在地をリストに記録するし、分岐があれば分岐に進む。
- [Topological Sort Visualized and Explained | Carl the Person](https://www.youtube.com/watch?v=7J3GadLzydI)が短くて分かりやすい。

### Tarjan's algorithm（Tarjanのアルゴリズム）

- 関節点を

### 参考

- 12章 グラフ
- 13章 重み付きグラフ
- 15章 高度なグラフアルゴリズム



## 参考

- [プログラミングコンテスト攻略のためのアルゴリズムとデータ構造](https://amzn.to/3QAHDSk)
- [Algorithms | Jeff Erickson (inzkyk訳)](https://booth.pm/ja/items/1633486)
- [アルゴリズム | ともめも](https://www.tomotaku.com/category/algorithm/)
