# Data structures and algorithms (データ構造・アルゴリズム)

## データ構造

### ヒープ

- 最小ヒープは、親が子よりも小さく、根が最小になるヒープ。単にヒープといえば最小ヒープ。
- 最大ヒープはその逆となる。
- 二分ヒープの読みは 「にぶん」ヒープ
- 二分ヒープと優先度付きキューの違いは、（WIP）

### Union-Find

互いに素な集合がある時に、ある2つの要素が同じ集合に属しているか？を調べることをUnion-Findという。

集合を木構造で表したとき、同じ集合に属しているか？を調べるのは根を求めることに等しく、計算量が$O(N)$となりえる。

しかし、union by rank を行うことで$O(log N) に、さらに経路圧縮を行うことで$O(α(N))$となる。$α(N)$はアッカーマンの逆関数と呼ばれ、増加がとても遅いことで知られる。[^Union-Find]

- union by rank: 2つの木を合体させるとき、背の高い木に背の低い木をつなげる
- 経路圧縮: find処理時、中間節点を全て根に繋ぎなおす

[^Union-Find]: [Union-Find の 2 つの工夫](https://algo-method.com/descriptions/133)

### データ構造: 参考

- 10章 ヒープ
- 14章 高度なデータ構造

## アルゴリズム

### 番兵

- `for`ループまたは`while`ループで、探索のための比較以外に終了条件の判定を行うことが面倒であるため、リストの最後に目的のデータをダミーで入れておく。
- Pythonでループを実装する場合や、TypeScriptで`find`などを用いる場合、勝手に最後まで探索してくれるので考慮不要。

### ハッシュの衝突

アルゴリズム図鑑で紹介されているチェーン法の他に、オープンアドレス法による対応がある。オープンアドレス法には、線形走査法とダブルハッシュ法がある。

- 線形走査法
  - 衝突が発生した場合、その1つ後ろの位置を格納箇所とする
  - 線形走査法・オープンアドレス法の両方に言えるが、いずれはハッシュ表が満杯になる。
- ダブルハッシュ法
  - ハッシュが衝突したら、引数に衝突回数を加えて再度ハッシュを求める。

[ハッシュ探索②（オープンアドレス法） | Programming Place Plus　アルゴリズムとデータ構造編【探索アルゴリズム】　第７章](https://programming-place.net/ppp/contents/algorithm/search/007.html#linear_probing)

### ソート

- 挿入ソート
  - カードの山を右手に取り、1番コストの低いカード、2番目にコストの低いカード…と、順番にカードを左手に移すイメージ。
  - 個人的には左手ソートと呼びたい。
- 選択ソート
  - データの先頭（または後方）が徐々に整理済みになっていく点は、挿入ソートと変わらない。
  - 1番小さい（大きい）値、2番目に小さい（大きい）値…と順番に探していく点と、値が見つかった後は元々n番目にいた値が入れ替わりで飛ばされてしまう点が異なる。
  - この入れ替わりで飛ばされてしまう点が面白いので、個人的には（ダンジョン飯の）ミスルンソートと呼びたい。
- バブルソート
  - 右から左に、小さい値がバトンタッチしながらやってくる様子から、個人的には玉突きソートと呼びたい。
- シェルソート
- マージソート
- クイックソート
  - 再帰的にパーティションを行う。
- 計数ソート
  - [計数ソート | アルゴリズムビジュアル大事典](https://yutaka-watanobe.github.io/star-aida/1.0/algorithms/counting_sort/print.html)を参照。
- 基数ソート

シェルソート

![シェルソート（螺旋本）](/images/シェルソート（螺旋本）.svg)

パーティション

![パーティション](/images/パーティション.svg)

## 木の探索

次の4通り。

- 深さ優先探索
  - 行きがけ順
    - 最もシンプル。迷路の右手法と同じ。
  - 通りがけ順
    - 西から順番に印を付けるイメージ。
  - 帰りがけ順
    - 個人的には行き止まり順だと思っている。
- 幅優先探索

### アルゴリズム: 参考

- 5章 探索
- 7章 高等的整列

## アルゴリズムの解析

アルゴリズムの実行時間を解析するうえで、私たちは実行時間が入力サイズに対して漸近的に増える効率に興味がある。入力サイズと相対的な実行時間を、おそらく計算量という。

計算量には時間計算量と領域計算量がある。単に計算量といえば、普通時間計算量を指す。領域計算量は空間計算量とも言う。

アルゴリズムの実行時間を表すための、漸近記法をまとめた。

![漸近記法](/images/漸近記法.svg)

- Θ記法: theta notation(シータ記法)
- 𝑂記法: big-o notation(ビッグオー記法)
  - アルファベットのO(オー)ではなく、ギリシャ文字のΟ(オミクロン)。
  - $f(x)=Ο(g(x))$のとき、$f(x)$が$g(x)$の定数倍と同じかそれより小さいことを指す。
- 𝑜記法: little-o notation(リトルオー記法, スモールオー記法)
  - $f(x)=ο(g(x))$のとき、$f(x)$が$g(x)$の定数倍より小さいことを指す。
- Ω記法: big-omega notation(ビッグオメガ記法)
  - $f(x)=Ω(g(x))$のとき、$f(x)$が$g(x)$の定数倍と同じかそれより大きいことを指す。
- 𝜔記法: little-omega notation(リトルオメガ記法)

なお、Ο(オミクロン)を変換するのが面倒なので、以降はアルファベットのO(オー)を用いる。

### アルゴリズムの解析: 参考

- [アルゴリズムイントロダクション 第3版 - 3 関数の増加](https://amzn.to/4avVZdK)
- [計算量の漸近記法（Θ記法・O記法・Ω記法・o記法・ω記法）](https://blog.publictheta.com/articles/qCAEowAbozLeMcFreq73f)
- 2章 アルゴリズムと計算量

## 再帰

- 再帰木
- 再帰方程式

## バックトラッキング

### バックトラッキングの問題

- 最長増加部分列
  - ある列に含まれる文字を、順序を崩さぬようにいくつか選んで再構成された列。
  - 列が元の列において連続である場合は「部分文字列」と呼ぶ。
  - 最長増加部分列とは、元のアルファベットなどの文字列の部分列のうち、a,b,c...の順番になっているようなものを指す。

## 動的計画法

- あずぱんさん曰く「表的計画法」。
  - [動的計画法(DP)をみんながわかるように超ていねいにじっくり説明した | あずぱん動画](動的計画法(DP)をみんながわかるように超ていねいにじっくり説明した)

### 動的計画法の問題

- 編集距離
- 連鎖行列積
  - なるべく大きい数字を早めに消してしまうのが方針となる。

### 動的計画法: 参考

- 11章 動的計画法

## 貪欲アルゴリズム

## グラフ

### グラフの性質

#### グラフの要素

- vertex(頂点) または node(ノード)
  - 辺$uv$および$u→v$について、頂点$u$と$v$を endpoint(端点)
    - $u→v$について、$u$をtail(尾), $v$をhead(頭)
  - source(ソース): 有向グラフにおいて、ある頂点に向かう辺がない頂点
  - sink(シンク): 有向グラフにおいて、ある頂点から出る辺がない頂点。シンクは沈む、流すといった意味
  
- edge(辺) または arc(アーク)
  - 特に有向辺をarcと呼ぶ場合もある
  - tree edge(木辺): ?
  - forward edge(前方辺): ?
  - backward edge(後方辺): ?
  - cross edge(交差辺): ?

- sequence(列): 頂点の列
  - walk(歩道): 隣接する頂点からなる列

#### グラフの種類

- 辺に向きがあるかどうか
  - directed graph(有効グラフ)
  - undirected graph(無向グラフ) または unordered graph

- ループ・多重辺を持っているか
  - simple: ループ・多重辺を持たないグラフ
  - multigraph(多重グラフ): ループ・多重辺を持つグラフ

- グラフ上のどの頂点からでも、他の頂点に行けるか？
  - connected graph(連結グラフ)
  - disconnected graph(非連結グラフ)
  - strongly connected(強連結): 有向グラフにおいて、どの頂点からでも他の頂点に行けること

- 閉路を含むか
  - cyclic graph(巡回グラフ)
  - acyclic graph(非巡回グラフ)

他に次のような定義がある。

- forest(森): 非巡回グラフ
- tree(木): 連結非巡回グラフ

#### グラフどうしの関係

グラフ$G=(V,E)$に対して、次のように定義される。

- subgraph(部分グラフ): 頂点と辺のいずれも$G$に含まれるグラフ
  - proper subgraph(真部分グラフ): subgraphであって、$G$と等しくないもの
  - isomorphic(同型): $G$と$G’$が、それぞれ対応する頂点と辺を持っている時、$G$と$G'$は同型
  - induced subgraph(誘導部分グラフ): $E'=E∩\binom{V}{2}$、つまり部分グラフ内のすべての頂点は、元のグラフ$G$で持っていた辺を持っている、ということ
  - spanning subgraph(全域部分グラフ): $V'=V$である部分グラフ。$G-e$や$G-F$で表される
    - spanning tree(全域木)
      - minimum spanning tree(最小全域木): 全域木のうち、合計の重みが最も軽い木。「すべての地域に電力を届けるための最も安いネットワークは？」といった応用がある。
      - shortest path spanning tree(最短路全域木): 単にshortest path tree(最短路木)といってこれを指すことが多い印象。
  - induced spanning subgraph(誘導全域部分グラフ): 定義する必要なし（それって同型なので）

なぜ誘導グラフと呼ぶかについては、[「生成部分グラフ」という用語について](http://www.co.mi.i.nagoya-u.ac.jp/~yagiura/surijoho8/induced_subgraph.pdf)を参照。

- reversal(逆): $G$のすべての辺$u→w$を$w→u$に取り換えたグラフ

- component(成分): 極大な連結部分グラフ
  - strongly connected component, strong component(強連結成分)
  - source component(ソース成分)
  - sink component(シンク成分)
- strong component graph(強連結成分グラフ): 強連結成分を1つの頂点にまとめたグラフ

### グラフの問題

- 到達可能性
- 成分の検出
- Articulation (関節点)の検出
- longest path(最長路)
- SSSP(Single Source Shortest Path, 単一始点最短経路、または単に最短路)
- APSP(All Pair Shortest Path, 全点対最短経路)

### グラフのデータ構造

- 隣接リスト
  - メモリが少ない（＝文字数が少なく済む）性質から、競プロでは、グラフは隣接リストに近い形式で渡されることが多い。
- 隣接行列

### 何か優先探索

グラフの探索には、深さ優先や幅優先などいろいろあるが、実は袋（＝候補となる辺を入れておくデータ構造）に何を採用するかの違いに過ぎない。

| 名前         | 袋                               | 解決する問題 |
| ------------ | -------------------------------- | ------------ |
| 深さ優先探索 | スタック                         |              |
| 幅優先探索   | キュー                           |              |
| 最良優先探索 | 優先度付きキュー                 |              |
| 最良優先探索 | 優先度付きキュー（辺の重み）     | 最小全域木   |
| 最良優先探索 | 優先度付きキュー（辺の重みの和） | 最短路木     |
| 最良優先探索 | 優先度付きキュー（路の幅）       | 最幅路       |

### Topological Sort（トポロジカルソート）

- 自分なりに言い換えると「左手法」。迷路の左手法と考え方が同じだから。
- 左手法の要領でグラフを探索し、そこから先は行き止まり、というところまで行ったら現在地をリストに記録する。
- 行き止まりから引き返すごとに、そこから先が行き止まりなら現在地をリストに記録するし、分岐があれば分岐に進む。
- [Topological Sort Visualized and Explained | Carl the Person](https://www.youtube.com/watch?v=7J3GadLzydI)が短くて分かりやすい。

### Strong Component(強連結成分)・Articulation(関節点)

強連結成分を計算するためのアルゴリズムは次の通り。線形時間で計算するための工夫がポイント。

- グラフの頂点全てに対して、お互いに到達できる点を何か優先探索で計算する（$O(VE)$）
- Kosaraju(コサラジュ)とSharir(シャリア)のアルゴリズム
  - 逆グラフの帰りがけ順に辿った頂点を、さらに逆順に何か優先探索する時に、何か優先探索がシンク成分の内側に留まることを利用したアルゴリズム
  <!-- TODO - 単にグラフの帰りがけ順ではない -->
- Tarjan(タージャン)のアルゴリズム
  <!-- TODO -->

<!-- TODO 関節点を求めるのに用いるのもTarjanやKosaraju? -->

### Minimum Spanning Tree, MST(最小全域木)アルゴリズム

いくつもアルゴリズムがあるが、次に述べる戦略の実装違いといえる。

その戦略とは、入力グラフ$G$に対して、その頂点だけからなる$F$（つまり、$F=(V, ∅)$）をintermediate spanning forest(中間全域森)として定義し、$F$に*いい感じ*の辺を徐々に加えていく戦略である。

<!-- ただの全域木の場合はO(E)なのに対して、最小全域木の場合はO(?)である理由 -->

#### Borůvka's algorighm(ブルーフカ法)

<!-- 解説 -->

```python
def boruvka(V, E):
  F = (V, ∅)
  count = count_and_label(F) # 成分数
  while count > 1:
    add_all_safe_edges(E, F, count)
    count ← count_and_label(F)
  return F
```

#### Jarník's (Prim's) algorithm(プリム法)

- 二分ヒープを用いることで高速化できる。
- [プリム法 (Prim's Algorithm) | サルでもわかるアルゴリズム](https://www.youtube.com/watch?v=anuJPP3FZ8c)が分かりやすかった。

#### Kruskal's algorighm(クラスカル法)

<!-- TODO -->

### Shortest Path(最短路)

#### Dijkstra's algorithm(ダイクストラ法)

- 自分なりに言い換えると、「近さランキング法」。
- 単一始点最短経路を求めるのに用いる。計算量は$O(|V|^2)$になる。
- 隣接リストと優先度付きキューを用いると、計算量は$O((|V|+|E|)log|V|)$になる。
  - [Dijkstra’s Algorithm | Depth First](https://www.youtube.com/watch?v=NyrHRNiRpds)が非常に分かりやすい。
  - ウィザードリィのような主観視点で例えると次の通り。
    1. 今いる場所（＝頂点）から見える場所について、1つづつ距離を書き留め、探索候補（優先度付きキュー）に加える。
    2. 全て書き留めたら、最も近い場所を候補から選んで進む。
    3. 同じく、進んだ先から見える場所について、1つづつ距離を測る。その時、すでに書き留めた場所だったなら、今いる場所を経由した方が近道である場合に限って書き留め、探索候補に加える。
    4. 書き留めたら、またスタートに戻ってから、次に近い場所に進む。これを場所の数繰り返す（注）
  - 注: 同じ場所を2回訪問することはない。言い換えると、探索候補の中で一番近い場所だけは、後からより近いルートが見つかることは無い。
- 螺旋本には、隣接リストと二分ヒープを用いると、計算量は$O((|V|+|E|)log|V|)$になる、とあるが...正直言って優先度付きキューでの実装より複雑だし計算量も変わらないので、私は理解していません...。

#### Bellman Ford's algorithm(ベルマンフォード法)

- ダイクストラ法とは異なり、負の重みがあっても機能する。
- また、負の閉路を検出できる。
- 完全にイメージだけの説明になるが…例えば本のページを逆から読んでいたとして、1周目に意味が理解できるのは1ページ目だけになる。2周目には、前の周回で1ページ目を読んでいるから2ページ目が理解できる。そのようにして、最悪でもページ数分周回すれば本の内容が理解できる、ということになる。という感じのアルゴリズム。
- [Bellman-Ford in 5 minutes | Michael Sambol](https://www.youtube.com/watch?v=obWXjtg0L64)が分かりやすい。

#### Johnson's algorithm(ジョンソン法)

- グラフに負の重みがある場合、ダイクストラ法が機能しない。
- 重みを変更し、負の重みをなくすことで、ダイクストラ法を機能させる方法。
<!-- TODO -->
- アルゴリズムの教科書では全組最短路のアルゴリズムとして紹介されている。

### All Pairs Shortest Path Problem(全組最短路)

#### 動的計画法による全組最短路

<!-- TODO -->

#### 動的計画法＋分割統治による全組最短路

<!-- TODO -->

#### Floyd–Warshall Algorithm（ワーシャルフロイド法）

<!-- TODO -->

### グラフの参考

- 12章 グラフ
- 13章 重み付きグラフ
- 15章 高度なグラフアルゴリズム

## 参考

- [プログラミングコンテスト攻略のためのアルゴリズムとデータ構造](https://amzn.to/3QAHDSk)
- [Algorithms | Jeff Erickson (inzkyk訳)](https://booth.pm/ja/items/1633486)
- [アルゴリズムイントロダクション 第3版 - 3 関数の増加](https://amzn.to/4avVZdK)
- [アルゴリズム | ともめも](https://www.tomotaku.com/category/algorithm/)
